.TH "mml::string" 3 "Mon Jun 10 2024" "mml" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mml::string
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <standards\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename templ > \fBstring\fP (templ \fBstr\fP) noexcept"
.br
.RI "Constructor with a value\&. "
.ti -1c
.RI "\fBstring\fP (size_t n, char c)"
.br
.RI "Constructor creating n times the char c\&. "
.ti -1c
.RI "\fBstring\fP ()"
.br
.RI "Constructor without a value\&. "
.ti -1c
.RI "template<typename templ > \fBmml::string\fP & \fBoperator=\fP (templ \fBstr\fP) noexcept"
.br
.RI "Assign the value of the template type with the '=' sign\&. "
.ti -1c
.RI "template<typename templ > bool \fBoperator==\fP (templ Test) noexcept"
.br
.RI "Operator equal\&. "
.ti -1c
.RI "template<typename templ > bool \fBoperator!=\fP (templ Test) noexcept"
.br
.RI "Operator unequal\&. "
.ti -1c
.RI "template<typename templ > \fBmml::string\fP \fBoperator+\fP (templ Test) noexcept"
.br
.RI "Operator add somehting at the end of this instance\&. "
.ti -1c
.RI "template<typename templ > \fBmml::string\fP \fBoperator+=\fP (templ add) noexcept"
.br
.RI "Operator add a char vector to this string\&. "
.ti -1c
.RI "char & \fBoperator[]\fP (int index)"
.br
.RI "Return a specific char from the string\&. "
.ti -1c
.RI "std::string & \fBoperator()\fP () noexcept"
.br
.RI "Returns the value\&. "
.ti -1c
.RI "double \fBatof\fP () noexcept"
.br
.RI "Converts this string into a double\&. "
.ti -1c
.RI "int \fBatoi\fP () noexcept"
.br
.RI "Convert this string into an integer\&. "
.ti -1c
.RI "std::string::iterator \fBbegin\fP () noexcept"
.br
.RI "Returns an iterator that points to the beginning of the string\&. "
.ti -1c
.RI "std::string::const_iterator \fBbegin\fP () const noexcept"
.br
.RI "Returns an iterator that points to the beginning of the string\&. "
.ti -1c
.RI "const char * \fBc_str\fP () noexcept"
.br
.RI "Returns the string as a character pointer\&. "
.ti -1c
.RI "void \fBclear\fP () noexcept"
.br
.RI "Clears the string\&. "
.ti -1c
.RI "uint32_t \fBcount\fP (\fBmml::string\fP name) noexcept"
.br
.RI "Count how often a string appears\&. "
.ti -1c
.RI "void \fBcout\fP (bool newline=true, std::string text='') noexcept"
.br
.RI "Print out the value of this instance\&. "
.ti -1c
.RI "std::string \fBdel_letter\fP (bool save=false) noexcept"
.br
.RI "Delete letters\&. "
.ti -1c
.RI "std::string \fBdel_number\fP (bool save=false) noexcept"
.br
.RI "Delete numbers\&. "
.ti -1c
.RI "std::string \fBdel_space\fP (bool save=false) noexcept"
.br
.RI "Remove everything after the first space\&. "
.ti -1c
.RI "bool \fBempty\fP () noexcept"
.br
.RI "Checks if the string is empty\&. "
.ti -1c
.RI "std::string::iterator \fBend\fP () noexcept"
.br
.RI "Returns an iterator that points to the end of the string\&. "
.ti -1c
.RI "std::string::const_iterator \fBend\fP () const noexcept"
.br
.RI "Returns an iterator that points to the end of the string\&. "
.ti -1c
.RI "template<typename\&.\&.\&. Args> bool \fBexist\fP (const Args &\&.\&.\&. args) noexcept"
.br
.RI "Check if one \fIor\fP another string exists\&. "
.ti -1c
.RI "std::size_t \fBfind\fP (char letter, std::size_t old=0) noexcept"
.br
.RI "Position of the first appearance of a character after a start position\&. "
.ti -1c
.RI "std::size_t \fBfind\fP (\fBmml::string\fP name, std::size_t old=0) noexcept"
.br
.RI "Position of the first appearance of a string after a start position\&. "
.ti -1c
.RI "std::size_t \fBfind_back\fP (\fBmml::string\fP name, std::size_t pos=0, std::size_t low=0) noexcept"
.br
.RI "Check if a string exists but starting from the right side\&. "
.ti -1c
.RI "void \fBgetline\fP (std::ifstream &input) noexcept"
.br
.RI "Reads a line from an input file stream and assigns it to the instance\&. "
.ti -1c
.RI "std::string \fBgetline\fP (std::string input, std::size_t line=0) noexcept"
.br
.RI "Reads a line from a file\&. "
.ti -1c
.RI "std::string \fBgetValue\fP () noexcept"
.br
.RI "Get the value of this instance\&. "
.ti -1c
.RI "uint32_t \fBhash\fP () noexcept"
.br
.RI "Creates a hash value of this instance\&. This hash value can then be used for example in an switch \&.\&.\&. case with strings by using hash values\&. "
.ti -1c
.RI "void \fBlog\fP (std::string logpath)"
.br
.RI "Writes the value of this instance into a log file\&. "
.ti -1c
.RI "std::string \fBlower\fP () noexcept"
.br
.RI "Transforms all letters into low case letters\&. "
.ti -1c
.RI "std::vector< std::string > \fBls\fP (std::string name_include, std::string name_exclude, std::vector< std::string > &directories, bool recursive=false, bool all=false)"
.br
.RI "List all files and directories in a path\&. Directories end with '/' in the entry\&. "
.ti -1c
.RI "std::vector< std::string > \fBls\fP (std::string name_include='', std::string name_exclude='', bool recursive=false, bool all=false)"
.br
.RI "List all files and directories in a path\&. Directories end with '/' in the entry\&. "
.ti -1c
.RI "bool \fBmkdir_p\fP () noexcept"
.br
.RI "Create directory with creating parent directories\&. "
.ti -1c
.RI "bool \fBremove\fP () noexcept"
.br
.RI "Remove the file with the value of the instance\&. "
.ti -1c
.RI "template<typename T > \fBmml::string\fP \fBreplace\fP (T str_old, T str_new, std::size_t pos=0)"
.br
.RI "Replace sth in the string with sth else\&. "
.ti -1c
.RI "std::size_t \fBrfind\fP (char letter) noexcept"
.br
.RI "Get position of last occurance of a character\&. "
.ti -1c
.RI "std::size_t \fBsize\fP () noexcept"
.br
.RI "Compute size of the string\&. "
.ti -1c
.RI "\fBmml::string\fP \fBsubstr\fP (std::size_t pos1, std::size_t length1) noexcept"
.br
.RI "Create substring\&. "
.ti -1c
.RI "\fBmml::string\fP \fBsubstr\fP (std::size_t pos1) noexcept"
.br
.RI "Create a substring starting from this position to the end\&. "
.ti -1c
.RI "\fBmml::string\fP \fBsub\fP (std::size_t beg, std::size_t \fBend\fP) noexcept"
.br
.RI "Create a substring starting and ending of specific positions\&. "
.ti -1c
.RI "int \fBstoi\fP () noexcept"
.br
.RI "Transform this instance to an integer\&. "
.ti -1c
.RI "std::string \fBstr\fP () noexcept"
.br
.RI "Return the value of this instance as a std::string\&. "
.ti -1c
.RI "void \fBwriteline\fP (std::ofstream &output) noexcept"
.br
.RI "Write this instance into the end of a file\&. "
.ti -1c
.RI "void \fBwriteline\fP (std::string output) noexcept"
.br
.RI "Write this instance into the end of a file\&. "
.ti -1c
.RI "\fB~string\fP ()"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "std::ostream & \fBoperator<<\fP (std::ostream &out, const \fBstring\fP &String) noexcept"
.br
.RI "Output the value of the string via a stream\&. "
.ti -1c
.RI "std::istream & \fBoperator>>\fP (std::istream &in, \fBstring\fP &String) noexcept"
.br
.RI "Input the value of the string via a stream\&. "
.in -1c
.SH "Detailed Description"
.PP 
Class string which adds additional functions to std::string 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename templ > mml::string::string (templ str)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Constructor with a value\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Value to be converted to a string 
.RE
.PP

.SS "mml::string::string (size_t n, char c)\fC [inline]\fP"

.PP
Constructor creating n times the char c\&. 
.PP
\fBParameters\fP
.RS 4
\fIn\fP how often the character c should appear 
.br
\fIc\fP Character which appears n times 
.RE
.PP

.SS "mml::string::string ()\fC [inline]\fP"

.PP
Constructor without a value\&. 
.SS "mml::string::~string ()\fC [inline]\fP"

.SH "Member Function Documentation"
.PP 
.SS "double mml::string::atof ()\fC [noexcept]\fP"

.PP
Converts this string into a double\&. 
.PP
\fBReturns\fP
.RS 4
double 
.RE
.PP

.SS "int mml::string::atoi ()\fC [noexcept]\fP"

.PP
Convert this string into an integer\&. 
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "std::string::const_iterator mml::string::begin () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns an iterator that points to the beginning of the string\&. 
.PP
\fBReturns\fP
.RS 4
std::string::const_iterator 
.RE
.PP

.SS "std::string::iterator mml::string::begin ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns an iterator that points to the beginning of the string\&. 
.PP
\fBReturns\fP
.RS 4
std::string::iterator 
.RE
.PP

.SS "const char * mml::string::c_str ()\fC [noexcept]\fP"

.PP
Returns the string as a character pointer\&. 
.PP
\fBReturns\fP
.RS 4
char* 
.RE
.PP

.SS "void mml::string::clear ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Clears the string\&. 
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP

.SS "uint32_t mml::string::count (\fBmml::string\fP name)\fC [noexcept]\fP"

.PP
Count how often a string appears\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP String which is counted 
.RE
.PP
\fBReturns\fP
.RS 4
uint32_t 
.RE
.PP

.SS "void mml::string::cout (bool newline = \fCtrue\fP, std::string text = \fC''\fP)\fC [noexcept]\fP"

.PP
Print out the value of this instance\&. 
.PP
\fBParameters\fP
.RS 4
\fInewline\fP Print newline\&. 
.br
\fItext\fP Additional text\&. 
.RE
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP

.SS "std::string mml::string::del_letter (bool save = \fCfalse\fP)\fC [noexcept]\fP"

.PP
Delete letters\&. 
.PP
\fBParameters\fP
.RS 4
\fIsave\fP Save the changed string in this instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
std::string 
.RE
.PP

.SS "std::string mml::string::del_number (bool save = \fCfalse\fP)\fC [noexcept]\fP"

.PP
Delete numbers\&. 
.PP
\fBParameters\fP
.RS 4
\fIsave\fP Save the changed string in this instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
std::string 
.RE
.PP

.SS "std::string mml::string::del_space (bool save = \fCfalse\fP)\fC [noexcept]\fP"

.PP
Remove everything after the first space\&. 
.PP
\fBParameters\fP
.RS 4
\fIsave\fP Save the changed string in this instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
std::string 
.RE
.PP

.SS "bool mml::string::empty ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Checks if the string is empty\&. 
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.SS "std::string::const_iterator mml::string::end () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns an iterator that points to the end of the string\&. 
.PP
\fBReturns\fP
.RS 4
std::string::const_iterator 
.RE
.PP

.SS "std::string::iterator mml::string::end ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Returns an iterator that points to the end of the string\&. 
.PP
\fBReturns\fP
.RS 4
std::string::iterator 
.RE
.PP

.SS "template<typename\&.\&.\&. Args> bool mml::string::exist (const Args &\&.\&.\&. args)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Check if one \fIor\fP another string exists\&. 
.PP
\fBParameters\fP
.RS 4
\fIargs\fP Parameters to be checked 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.SS "std::size_t mml::string::find (char letter, std::size_t old = \fC0\fP)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Position of the first appearance of a character after a start position\&. 
.PP
\fBParameters\fP
.RS 4
\fIletter\fP Value 
.br
\fIold\fP Value from where to search for the char\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Position 
.RE
.PP

.SS "std::size_t mml::string::find (\fBmml::string\fP name, std::size_t old = \fC0\fP)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Position of the first appearance of a string after a start position\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP Value 
.br
\fIold\fP Value from where to search for the char\&. 
.RE
.PP
\fBReturns\fP
.RS 4
Position 
.RE
.PP

.SS "std::size_t mml::string::find_back (\fBmml::string\fP name, std::size_t pos = \fC0\fP, std::size_t low = \fC0\fP)\fC [noexcept]\fP"

.PP
Check if a string exists but starting from the right side\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP String to look for 
.br
\fIpos\fP Value from where to search for the string\&. 0 means that it is not used\&. 
.br
\fIlow\fP Lower limit to which point is searched for\&. 
.RE
.PP
\fBReturns\fP
.RS 4
std::size_t 
.RE
.PP

.SS "void mml::string::getline (std::ifstream & input)\fC [noexcept]\fP"

.PP
Reads a line from an input file stream and assigns it to the instance\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP 
.RE
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP

.SS "std::string mml::string::getline (std::string input, std::size_t line = \fC0\fP)\fC [noexcept]\fP"

.PP
Reads a line from a file\&. 
.PP
\fBParameters\fP
.RS 4
\fIinput\fP File name 
.br
\fIline\fP Line number\&. 
.RE
.PP
\fBReturns\fP
.RS 4
std::tring 
.RE
.PP

.SS "std::string mml::string::getValue ()\fC [noexcept]\fP"

.PP
Get the value of this instance\&. 
.PP
\fBReturns\fP
.RS 4
std::string 
.RE
.PP

.SS "uint32_t mml::string::hash ()\fC [noexcept]\fP"

.PP
Creates a hash value of this instance\&. This hash value can then be used for example in an switch \&.\&.\&. case with strings by using hash values\&. 
.PP
\fBReturns\fP
.RS 4
uint32_t 
.RE
.PP

.SS "void mml::string::log (std::string logpath)"

.PP
Writes the value of this instance into a log file\&. 
.PP
\fBParameters\fP
.RS 4
\fIlogpath\fP Path to the logfile 
.RE
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIruntime_error\fP : if permission to create log file is denied 
.RE
.PP

.SS "std::string mml::string::lower ()\fC [noexcept]\fP"

.PP
Transforms all letters into low case letters\&. 
.PP
\fBReturns\fP
.RS 4
std::string 
.RE
.PP

.SS "std::vector< std::string > mml::string::ls (std::string name_include, std::string name_exclude, std::vector< std::string > & directories, bool recursive = \fCfalse\fP, bool all = \fCfalse\fP)"

.PP
List all files and directories in a path\&. Directories end with '/' in the entry\&. 
.PP
\fBParameters\fP
.RS 4
\fIname_include\fP Only list files or directories which include this string in the name\&. 
.br
\fIname_exclude\fP Exclude files or directories with this string in the name 
.br
\fIdirectories\fP Reference to a vector where the directories are added 
.br
\fIrecursive\fP Check directory recursively 
.br
\fIall\fP Also list hidden files 
.RE
.PP
\fBReturns\fP
.RS 4
std::vector<std::string> 
.RE
.PP
\fBNote\fP
.RS 4
If name_include or name_exclude is detected for a directory, all the elements in this directory are either included or excluded, respectively\&. 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIruntime_error\fP : if the string does not exist 
.RE
.PP

.SS "std::vector< std::string > mml::string::ls (std::string name_include = \fC''\fP, std::string name_exclude = \fC''\fP, bool recursive = \fCfalse\fP, bool all = \fCfalse\fP)"

.PP
List all files and directories in a path\&. Directories end with '/' in the entry\&. 
.PP
\fBParameters\fP
.RS 4
\fIname_include\fP Only list files or directories which include this string in the name\&. 
.br
\fIname_exclude\fP Exclude files or directories with this string in the name 
.br
\fIrecursive\fP Check directory recursively 
.br
\fIall\fP Also list hidden files 
.RE
.PP
\fBReturns\fP
.RS 4
std::vector<std::string> 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIruntime_error\fP : if the string does not exist 
.RE
.PP
\fBNote\fP
.RS 4
If name_include or name_exclude is detected for a directory, all the elements in this directory are either included or excluded, respectively\&. 
.RE
.PP

.SS "bool mml::string::mkdir_p ()\fC [noexcept]\fP"

.PP
Create directory with creating parent directories\&. 
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.SS "template<typename templ > bool mml::string::operator!= (templ Test)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Operator unequal\&. 
.PP
\fBParameters\fP
.RS 4
\fITest\fP Value 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.SS "std::string & mml::string::operator() ()\fC [noexcept]\fP"

.PP
Returns the value\&. 
.PP
\fBReturns\fP
.RS 4
Value of the instance as a std::string 
.RE
.PP

.SS "template<typename templ > \fBmml::string\fP mml::string::operator+ (templ Test)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Operator add somehting at the end of this instance\&. 
.PP
\fBParameters\fP
.RS 4
\fITest\fP Value to be added 
.RE
.PP
\fBReturns\fP
.RS 4
\fBmml::string\fP 
.RE
.PP

.SS "template<typename templ > \fBmml::string\fP mml::string::operator+= (templ add)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Operator add a char vector to this string\&. 
.PP
\fBParameters\fP
.RS 4
\fIadd\fP Value to be added 
.RE
.PP
\fBReturns\fP
.RS 4
\fBmml::string\fP 
.RE
.PP

.SS "template<typename templ > \fBmml::string\fP& mml::string::operator= (templ str)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Assign the value of the template type with the '=' sign\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP Value 
.RE
.PP
\fBReturns\fP
.RS 4
Class instance 
.RE
.PP

.SS "template<typename templ > bool mml::string::operator== (templ Test)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Operator equal\&. 
.PP
\fBParameters\fP
.RS 4
\fITest\fP Value 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.SS "char & mml::string::operator[] (int index)"

.PP
Return a specific char from the string\&. 
.PP
\fBParameters\fP
.RS 4
\fIindex\fP Index of the character to be retured 
.RE
.PP
\fBReturns\fP
.RS 4
char 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIlogic_error\fP : if out of range 
.RE
.PP

.SS "bool mml::string::remove ()\fC [noexcept]\fP"

.PP
Remove the file with the value of the instance\&. 
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.SS "template<typename T > \fBmml::string\fP mml::string::replace (T str_old, T str_new, std::size_t pos = \fC0\fP)\fC [inline]\fP"

.PP
Replace sth in the string with sth else\&. 
.PP
\fBParameters\fP
.RS 4
\fIstr_old\fP Replace this value 
.br
\fIstr_new\fP Replaced with this value 
.br
\fIpos\fP Start from this position to replace 
.RE
.PP
\fBReturns\fP
.RS 4
\fBmml::string\fP 
.RE
.PP
\fBExceptions\fP
.RS 4
\fIinvalid_argument\fP : if str_old is empty 
.RE
.PP

.SS "std::size_t mml::string::rfind (char letter)\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Get position of last occurance of a character\&. 
.PP
\fBParameters\fP
.RS 4
\fIletter\fP Value to be found 
.RE
.PP
\fBReturns\fP
.RS 4
std::size_t 
.RE
.PP

.SS "std::size_t mml::string::size ()\fC [noexcept]\fP"

.PP
Compute size of the string\&. 
.PP
\fBReturns\fP
.RS 4
std::size_t 
.RE
.PP

.SS "int mml::string::stoi ()\fC [noexcept]\fP"

.PP
Transform this instance to an integer\&. 
.PP
\fBReturns\fP
.RS 4
int 
.RE
.PP

.SS "std::string mml::string::str ()\fC [noexcept]\fP"

.PP
Return the value of this instance as a std::string\&. 
.PP
\fBReturns\fP
.RS 4
std::string 
.RE
.PP

.SS "\fBmml::string\fP mml::string::sub (std::size_t beg, std::size_t end)\fC [noexcept]\fP"

.PP
Create a substring starting and ending of specific positions\&. 
.PP
\fBParameters\fP
.RS 4
\fIbeg\fP Start of the new string 
.br
\fIend\fP End of the new string 
.RE
.PP
\fBReturns\fP
.RS 4
\fBmml::string\fP 
.RE
.PP

.SS "\fBmml::string\fP mml::string::substr (std::size_t pos1)\fC [noexcept]\fP"

.PP
Create a substring starting from this position to the end\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos1\fP Start position to the end 
.RE
.PP
\fBReturns\fP
.RS 4
\fBmml::string\fP 
.RE
.PP

.SS "\fBmml::string\fP mml::string::substr (std::size_t pos1, std::size_t length1)\fC [noexcept]\fP"

.PP
Create substring\&. 
.PP
\fBParameters\fP
.RS 4
\fIpos1\fP Start position 
.br
\fIlength1\fP Length of the string 
.RE
.PP
\fBReturns\fP
.RS 4
\fBmml::string\fP 
.RE
.PP

.SS "void mml::string::writeline (std::ofstream & output)\fC [noexcept]\fP"

.PP
Write this instance into the end of a file\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutput\fP Write to this output file stream 
.RE
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP

.SS "void mml::string::writeline (std::string output)\fC [noexcept]\fP"

.PP
Write this instance into the end of a file\&. 
.PP
\fBParameters\fP
.RS 4
\fIoutput\fP Path to the file 
.RE
.PP
\fBReturns\fP
.RS 4
None 
.RE
.PP

.SH "Friends And Related Function Documentation"
.PP 
.SS "std::ostream& operator<< (std::ostream & out, const \fBstring\fP & String)\fC [friend]\fP"

.PP
Output the value of the string via a stream\&. 
.PP
\fBParameters\fP
.RS 4
\fIout\fP output stream 
.br
\fIString\fP Value 
.RE
.PP
\fBReturns\fP
.RS 4
ostream 
.RE
.PP

.SS "std::istream& operator>> (std::istream & in, \fBstring\fP & String)\fC [friend]\fP"

.PP
Input the value of the string via a stream\&. 
.PP
\fBParameters\fP
.RS 4
\fIin\fP Input stream 
.br
\fIString\fP Value 
.RE
.PP
\fBReturns\fP
.RS 4
istream 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for mml from the source code\&.
